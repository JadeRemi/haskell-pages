{-# LANGUAGE OverloadedStrings #-}import Reflex.Domdata Cell = X | O | Blankdata Game = Game { gameBoard :: [[Cell]], gameTurn :: Cell }blankGame :: GameblankGame = Game { gameBoard = replicate 3 (replicate 3 Blank), gameTurn = X }cellSymbol :: Cell -> StringcellSymbol X = "X"cellSymbol O = "O"cellSymbol Blank = " "toggleCell :: Int -> Int -> Game -> GametoggleCell row col game =    let oldCell = (gameBoard game) !! row !! col        newCell = case oldCell of            Blank -> gameTurn game            _ -> oldCell        newBoard = setElem newCell (row, col) (gameBoard game)        newTurn = case gameTurn game of            X -> O            O -> X    in Game { gameBoard = newBoard, gameTurn = newTurn }renderCell :: MonadWidget t m => Int -> Int -> Cell -> m ()renderCell row col cell =    elClass "td" ("cell " <> cellSymbol cell) $        el "button" $ text (cellSymbol cell)renderRow :: MonadWidget t m => Int -> [Cell] -> m ()renderRow row cells =    el "tr" $ mapM_ (uncurry (renderCell row)) (zip [0..] cells)renderBoard :: MonadWidget t m => [[Cell]] -> m ()renderBoard board =    elClass "table" "board" $ mapM_ (uncurry renderRow) (zip [0..] board)renderGame :: MonadWidget t m => Game -> m (Event t Game)renderGame game = do    let board = gameBoard game    renderBoard board    cellClicks <- fmap switchPromptlyDyn $ foldDyn id (const never) $        mergeWith (.) $ [ const (toggleCell row col) <$ ev                        | row <- [0..2], col <- [0..2], board !! row !! col == Blank                        , let cellEl = (getElementById $ "cell-" <> show row <> "-" <> show col) ^. _1                        , Just ev <- [domEvent Click cellEl]                        ]    return $ cellClicks gamemain :: IO ()main = mainWidget $ do    rec game <- foldDyn const blankGame gameEvent        gameEvent <- renderGame game    return ()